<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UKMR to Dot - 40x48 Pixel Art Converter</title>
    <!-- Material Icons & Roboto Font -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        :root {
            /* Material Design 2 Color Palette */
            --md-primary: #3F51B5; /* Indigo 500 */
            --md-primary-dark: #303F9F;
            --md-secondary: #E91E63; /* Pink 500 */
            --md-background: #FAFAFA;
            --md-surface: #FFFFFF;
            --md-on-primary: #FFFFFF;
            --md-on-secondary: #FFFFFF;
            --md-on-surface: rgba(0, 0, 0, 0.87);
            
            /* Shadows */
            --shadow-2: 0 3px 1px -2px rgba(0,0,0,0.2), 0 2px 2px 0 rgba(0,0,0,0.14), 0 1px 5px 0 rgba(0,0,0,0.12);
            --shadow-4: 0 2px 4px -1px rgba(0,0,0,0.2), 0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12);
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--md-background);
            color: var(--md-on-surface);
            margin: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* App Bar */
        .app-bar {
            background-color: var(--md-primary);
            color: var(--md-on-primary);
            height: 64px;
            display: flex;
            align-items: center;
            padding: 0 24px;
            box-shadow: var(--shadow-4);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .app-bar h1 {
            font-size: 20px;
            font-weight: 500;
            margin: 0;
            letter-spacing: 0.15px;
        }

        /* Main Layout */
        main {
            flex: 1;
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }

        /* Card */
        .card {
            background: var(--md-surface);
            border-radius: 4px;
            box-shadow: var(--shadow-2);
            padding: 24px;
            width: 100%;
            max-width: 500px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .card-header {
            width: 100%;
            margin-bottom: 24px;
        }

        .card-title {
            font-size: 20px;
            font-weight: 500;
            margin: 0 0 8px 0;
        }

        .card-subtitle {
            font-size: 14px;
            color: rgba(0,0,0,0.6);
            margin: 0;
            line-height: 1.5;
        }

        /* Canvas Wrapper */
        .preview-container {
            position: relative;
            margin-bottom: 24px;
            padding: 8px;
            border: 1px solid rgba(0,0,0,0.12);
            border-radius: 4px;
            background-color: #fff;
            
            /* Checkerboard pattern for transparency */
            background-image: 
                linear-gradient(45deg, #eee 25%, transparent 25%), 
                linear-gradient(-45deg, #eee 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #eee 75%), 
                linear-gradient(-45deg, transparent 75%, #eee 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        canvas {
            display: block;
            width: 100%;
            max-width: 300px; /* 表示サイズは適度に抑える */
            height: auto;
            image-rendering: pixelated; /* プレビューでのボケ防止 */
            box-shadow: 0 0 0 1px rgba(0,0,0,0.05);
        }

        .placeholder-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(0,0,0,0.38);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            width: 100%;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 16px;
            width: 100%;
            justify-content: flex-end;
            align-items: center;
            flex-wrap: wrap;
        }

        /* Material Buttons */
        .btn {
            height: 36px;
            padding: 0 16px;
            border-radius: 4px;
            border: none;
            font-family: inherit;
            font-size: 14px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1.25px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, box-shadow 0.2s;
            outline: none;
            position: relative;
            overflow: hidden;
        }

        .btn i {
            font-size: 18px;
            margin-right: 8px;
        }

        .btn-outlined {
            background: transparent;
            color: var(--md-primary);
            border: 1px solid rgba(0,0,0,0.12);
        }

        .btn-outlined:hover {
            background-color: rgba(63, 81, 181, 0.04);
            border-color: var(--md-primary);
        }

        .btn-contained {
            background: var(--md-secondary);
            color: var(--md-on-secondary);
            box-shadow: var(--shadow-2);
        }

        .btn-contained:hover {
            background-color: #D81B60;
            box-shadow: var(--shadow-4);
        }

        .btn-contained:disabled {
            background-color: rgba(0,0,0,0.12);
            color: rgba(0,0,0,0.38);
            box-shadow: none;
            cursor: default;
        }

        /* Chip/Badge for info */
        .info-chip {
            background: rgba(0,0,0,0.08);
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 12px;
            color: rgba(0,0,0,0.6);
            margin-bottom: 16px;
            display: none; /* JSで表示制御 */
        }

        /* Snackbar */
        #snackbar {
            visibility: hidden;
            min-width: 250px;
            background-color: #323232;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 14px 24px;
            position: fixed;
            z-index: 1000;
            left: 24px;
            bottom: 24px;
            font-size: 14px;
            box-shadow: var(--shadow-4);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #snackbar.show {
            visibility: visible;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>

    <header class="app-bar">
        <h1>UKMR to Dot</h1>
    </header>

    <main>
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">画像の変換</h2>
                <p class="card-subtitle">
                    40x48ピクセルのドット絵に変換します。<br>
                    出力画像サイズは <strong>400x480px</strong> (1ドット=10px) です。
                </p>
            </div>

            <div class="info-chip" id="resolutionInfo">
                Grid: 40x48 | Output: 400x480px
            </div>

            <!-- 表示用キャンバス (実際には400x480で描画される) -->
            <div class="preview-container">
                <canvas id="displayCanvas" width="400" height="480"></canvas>
                <div class="placeholder-text" id="placeholder">
                    <span class="material-icons" style="font-size: 48px; margin-bottom: 8px; color: rgba(0,0,0,0.2);">image</span>
                    <span>No Image</span>
                </div>
            </div>

            <div class="controls">
                <input type="file" id="fileInput" accept="image/*">
                
                <button class="btn btn-outlined" onclick="document.getElementById('fileInput').click()">
                    <i class="material-icons">add_photo_alternate</i>
                    画像を選択
                </button>

                <button class="btn btn-contained" id="exportBtn" disabled onclick="downloadImage()">
                    <i class="material-icons">save_alt</i>
                    保存 (PNG)
                </button>
            </div>
        </div>
    </main>

    <div id="snackbar">
        <span id="snackbarMsg">画像を保存しました</span>
    </div>

    <!-- 処理用・隠しキャンバス (40x48) -->
    <canvas id="processCanvas" width="40" height="48" style="display: none;"></canvas>

    <script>
        const fileInput = document.getElementById('fileInput');
        const processCanvas = document.getElementById('processCanvas');
        const displayCanvas = document.getElementById('displayCanvas');
        const exportBtn = document.getElementById('exportBtn');
        const placeholder = document.getElementById('placeholder');
        const resolutionInfo = document.getElementById('resolutionInfo');

        // コンテキスト取得 (ピクセル操作用)
        const processCtx = processCanvas.getContext('2d', { willReadFrequently: true });
        const displayCtx = displayCanvas.getContext('2d');

        // ピクセルのボケを防ぐ設定
        processCtx.imageSmoothingEnabled = false;
        displayCtx.imageSmoothingEnabled = false;

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    convertImage(img);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        function convertImage(img) {
            // 1. 小さいキャンバス(40x48)をクリアして画像を縮小描画
            // これにより強制的に40x48の情報量に落とす
            processCtx.clearRect(0, 0, 40, 48);
            processCtx.drawImage(img, 0, 0, 40, 48);

            // 2. 縮小した画像のピクセルデータを取得
            const imageData = processCtx.getImageData(0, 0, 40, 48);
            const data = imageData.data;

            // 3. 大きいキャンバス(400x480)をクリア
            displayCtx.clearRect(0, 0, 400, 480);

            // 4. ピクセルデータを元に、10x10の矩形(ドット)を描画
            const dotSize = 10; // 1ドットのピクセルサイズ

            for (let y = 0; y < 48; y++) {
                for (let x = 0; x < 40; x++) {
                    const index = (y * 40 + x) * 4;
                    
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    const a = data[index + 3];

                    // 透明度がある場合のみ描画
                    if (a > 0) {
                        displayCtx.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
                        // 座標を10倍して、10x10の正方形を描く
                        displayCtx.fillRect(x * dotSize, y * dotSize, dotSize, dotSize);
                    }
                }
            }

            // UI更新
            placeholder.style.display = 'none';
            resolutionInfo.style.display = 'block';
            exportBtn.disabled = false;
            
            showSnackbar("変換完了: 40x48ドット (400x480px)");
        }

        function downloadImage() {
            // 表示用キャンバスは既に400x480pxの高解像度ドット絵になっている
            const dataUrl = displayCanvas.toDataURL("image/png");
            
            // 現在時刻でファイル名生成
            const now = new Date();
            const timeStr = now.toISOString().slice(0,19).replace(/[-T:]/g,"");
            const filename = `ukmr_dot_${timeStr}.png`;

            const link = document.createElement('a');
            link.download = filename;
            link.href = dataUrl;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showSnackbar("画像をダウンロードしました");
        }

        function showSnackbar(msg) {
            const sb = document.getElementById("snackbar");
            const sbMsg = document.getElementById("snackbarMsg");
            sbMsg.textContent = msg;
            
            sb.className = "show";
            
            // 既存のタイマーがあればリセットすべきだが簡易実装として
            setTimeout(() => { sb.className = sb.className.replace("show", ""); }, 3000);
        }
    </script>
</body>
</html>
